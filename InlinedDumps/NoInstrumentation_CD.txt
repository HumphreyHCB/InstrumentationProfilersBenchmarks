VM Arguments: 
sun.java.command=Harness CD 10 1000
                              @ 17  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.175284, probability=0.148218, bonus=1.000000, nodes=9)
                              @ 27  java.lang.StringLatin1.hashCode(byte[]):int (52 bytes)   relevance-based (relevance=0.175284, probability=0.148218, bonus=1.000000, nodes=22 <= 52.585339)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.242479, probability=1.521199, bonus=1.000000, nodes=20 <= 72.743576)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.469381, probability=1.521199, bonus=1.000000, nodes=20 <= 140.814262)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.242479, probability=1.521199, bonus=1.000000, nodes=46 <= 72.743576)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=7.569477, bonus=1.000000, nodes=12 <= 300.000000)
                              @ 25  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.206572, probability=9.090676, bonus=1.000000, nodes=65 <= 300.000000)
                              @ 96  cd.RedBlackTree$Node.<init>(Object, Object):void (37 bytes)   relevance-based (relevance=0.615116, probability=0.615116, bonus=1.000000, nodes=21 <= 184.534674)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.298850, probability=0.188661, bonus=1.000000, nodes=20 <= 89.654951)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.578502, probability=0.188661, bonus=1.000000, nodes=20 <= 173.550663)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.298850, probability=0.188661, bonus=1.000000, nodes=46 <= 89.654951)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=0.511676, probability=0.323016, bonus=1.000000, nodes=12 <= 153.502863)
                              @ 128  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=0.511676, probability=0.511676, bonus=1.000000, nodes=65 <= 153.502863)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.051625, probability=5.193311, bonus=1.000000, nodes=20 <= 300.000000)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.837706, probability=4.938367, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=5.193311, bonus=1.000000, nodes=49 <= 300.000000)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=5.394321, bonus=1.000000, nodes=12 <= 300.000000)
                              @ 17  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.368317, probability=10.587632, bonus=1.000000, nodes=68 <= 300.000000)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.571080, probability=2.310741, bonus=1.000000, nodes=20 <= 171.324104)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.969620, probability=2.156594, bonus=1.000000, nodes=20 <= 290.886105)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.532984, probability=2.310741, bonus=1.000000, nodes=49 <= 159.895237)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=5.348384, bonus=1.000000, nodes=12 <= 300.000000)
                              @ 25  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.233632, probability=7.659125, bonus=1.000000, nodes=68 <= 300.000000)
                              @ 96  cd.RedBlackTree$Node.<init>(Object, Object):void (37 bytes)   relevance-based (relevance=0.541347, probability=0.541347, bonus=1.000000, nodes=21 <= 162.404172)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=0.429451, probability=0.223394, bonus=1.000000, nodes=12 <= 128.835401)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.498863, probability=0.242190, bonus=1.000000, nodes=20 <= 149.658909)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.847005, probability=0.226034, bonus=1.000000, nodes=20 <= 254.101414)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.465584, probability=0.242190, bonus=1.000000, nodes=49 <= 139.675307)
                              @ 128  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=0.465584, probability=0.465584, bonus=1.000000, nodes=68 <= 139.675307)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=0.474387, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.067466, probability=0.494985, bonus=1.000000, nodes=20 <= 300.000000)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.832099, probability=0.463701, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=0.494985, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 17  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.355177, probability=0.969372, bonus=1.000000, nodes=69 <= 300.000000)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=4.786836, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.067466, probability=4.994683, bonus=1.000000, nodes=20 <= 300.000000)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.832099, probability=4.679007, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=4.994683, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 17  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.355177, probability=9.781519, bonus=1.000000, nodes=69 <= 300.000000)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.549435, probability=2.312368, bonus=1.000000, nodes=20 <= 164.830418)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.947789, probability=2.173136, bonus=1.000000, nodes=20 <= 284.336590)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.516352, probability=2.312368, bonus=1.000000, nodes=49 <= 154.905657)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=5.522893, bonus=1.000000, nodes=13 <= 300.000000)
                              @ 25  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.233263, probability=7.835262, bonus=1.000000, nodes=69 <= 300.000000)
                              @ 96  cd.RedBlackTree$Node.<init>(Object, Object):void (37 bytes)   relevance-based (relevance=0.551957, probability=0.551957, bonus=1.000000, nodes=21 <= 165.587000)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=0.454337, probability=0.232307, bonus=1.000000, nodes=13 <= 136.301007)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.505824, probability=0.243061, bonus=1.000000, nodes=20 <= 151.747339)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.872560, probability=0.228425, bonus=1.000000, nodes=20 <= 261.767953)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.475368, probability=0.243061, bonus=1.000000, nodes=49 <= 142.610336)
                              @ 128  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=0.475368, probability=0.475368, bonus=1.000000, nodes=69 <= 142.610336)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=5.260098, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.073863, probability=5.489856, bonus=1.000000, nodes=20 <= 300.000000)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.818850, probability=5.112249, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=5.489856, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 17  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.355135, probability=10.749954, bonus=1.000000, nodes=69 <= 300.000000)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                              @ 3  cd.RedBlackTree.treeInsert(Comparable, Object):RedBlackTree$InsertResult (163 bytes)   not inlining too large previous low-level graph (low-level-nodes: 1004, relevance=1.849109, probability=1.000000, bonus=1.000000, nodes=102)
                              @ 165  cd.RedBlackTree.leftRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.020293, probability=0.007089, bonus=1.000000, nodes=47 > 6.087812)
                              @ 308  cd.RedBlackTree.rightRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.055980, probability=0.019556, bonus=1.000000, nodes=47 > 16.794031)
                              @ 203  cd.RedBlackTree.rightRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.044868, probability=0.015674, bonus=1.000000, nodes=47 > 13.460321)
                              @ 346  cd.RedBlackTree.leftRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   relevance-based (relevance=0.969769, probability=0.338769, bonus=1.000000, nodes=47 <= 290.930790)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.588431, probability=2.319062, bonus=1.000000, nodes=20 <= 176.529428)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.991390, probability=2.151781, bonus=1.000000, nodes=20 <= 297.416955)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.545986, probability=2.319062, bonus=1.000000, nodes=49 <= 163.795786)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   trivial (relevance=1.000000, probability=5.295674, bonus=1.000000, nodes=8)
                              @ 25  cd.CallSign.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.246781, probability=7.614737, bonus=1.000000, nodes=64 <= 300.000000)
                              @ 96  cd.RedBlackTree$Node.<init>(Object, Object):void (37 bytes)   relevance-based (relevance=0.544504, probability=0.544504, bonus=1.000000, nodes=21 <= 163.351281)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   trivial (relevance=0.423729, probability=0.223100, bonus=1.000000, nodes=8)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.507818, probability=0.248087, bonus=1.000000, nodes=20 <= 152.345301)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=0.855572, probability=0.230192, bonus=1.000000, nodes=20 <= 256.671513)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=0.471187, probability=0.248087, bonus=1.000000, nodes=49 <= 141.356138)
                              @ 128  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=0.471187, probability=0.471187, bonus=1.000000, nodes=64 <= 141.356138)
                                @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   trivial (relevance=1.000000, probability=5.116909, bonus=1.000000, nodes=8)
                                  @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.087015, probability=5.511304, bonus=1.000000, nodes=20 <= 300.000000)
                                  @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.802318, probability=5.070127, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=5.511304, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 17  cd.Vector2D.compareTo(Object):int (9 bytes)   relevance-based (relevance=1.373022, probability=10.628213, bonus=1.000000, nodes=64 <= 300.000000)
                              @ 13  cd.RedBlackTree.treeMinimum(RedBlackTree$Node):RedBlackTree$Node (19 bytes)   relevance-based (relevance=1.000000, probability=0.514183, bonus=1.000000, nodes=16 <= 300.000000)
                            @ 83  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                            @ 159  cd.RedBlackTree$InsertResult.<init>(boolean, RedBlackTree$Node, Object):void (20 bytes)   inline method (bytecode parsing)
                              @ 3  cd.RedBlackTree.treeInsert(Comparable, Object):RedBlackTree$InsertResult (163 bytes)   not inlining too large previous low-level graph (low-level-nodes: 1012, relevance=1.856776, probability=1.000000, bonus=1.000000, nodes=102)
                              @ 308  cd.RedBlackTree.rightRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.047493, probability=0.015406, bonus=1.000000, nodes=47 > 14.247814)
                              @ 165  cd.RedBlackTree.leftRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.042581, probability=0.013812, bonus=1.000000, nodes=47 > 12.774288)
                              @ 346  cd.RedBlackTree.leftRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   relevance-based (relevance=0.999958, probability=0.324363, bonus=1.000000, nodes=47 <= 299.987282)
                              @ 203  cd.RedBlackTree.rightRotate(RedBlackTree$Node):RedBlackTree$Node (93 bytes)   not inlining relevance-based (relevance=0.067024, probability=0.021741, bonus=1.000000, nodes=47 > 20.107219)
                                @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.085967, probability=1.000000, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.804595, probability=0.920839, bonus=1.000000, nodes=20 <= 300.000000)
                              @ 5  cd.Vector2D.compareTo(Vector2D):int (30 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 8  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.085967, probability=1.000000, bonus=1.000000, nodes=20 <= 300.000000)
                              @ 26  cd.Vector2D.compareNumbers(double, double):int (34 bytes)   relevance-based (relevance=1.804595, probability=0.920839, bonus=1.000000, nodes=20 <= 300.000000)
                              @ 2  cd.CollisionDetector.isInVoxel(Vector2D, Motion):boolean (420 bytes)   relevance-based (relevance=1.369354, probability=1.000000, bonus=1.000000, nodes=213 <= 300.000000)
                              @ 15  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=0.564383, probability=0.269544, bonus=1.000000, nodes=163)
                            @ 17  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                                  @ 2  cd.RedBlackTree.findNode(Comparable):RedBlackTree$Node (51 bytes)   not inlining too large previous low-level graph (low-level-nodes: 345, relevance=0.459182, probability=0.109115, bonus=1.000000, nodes=42)
                                @ 2  cd.RedBlackTree.get(Comparable):Object (17 bytes)   relevance-based (relevance=0.289806, probability=0.109115, bonus=1.000000, nodes=15 <= 86.941896)
                                @ 24  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=0.285383, probability=0.086022, bonus=1.000000, nodes=163)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.001453, probability=0.000436, bonus=1.000000, nodes=41 > 0.435784)
                                @ 30  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=0.361998, probability=0.109115, bonus=1.000000, nodes=35 <= 108.599498)
                              @ 28  cd.CollisionDetector.putIntoMap(RedBlackTree, Vector2D, Motion):void (34 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=80 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 37  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                              @ 41  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 50  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                              @ 54  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 63  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                              @ 67  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 76  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                              @ 80  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 89  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 95  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                              @ 99  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 108  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 114  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                              @ 118  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 127  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 133  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=16 <= 68.541108)
                              @ 137  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 146  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=11 <= 68.541108)
                              @ 152  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=18 <= 68.541108)
                              @ 156  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining relevance-based (relevance=0.228470, probability=0.109115, bonus=1.000000, nodes=92 > 68.541108)
                              @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                              @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.004018, probability=0.004002, bonus=1.000000, nodes=41 > 1.205517)
                              @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 12  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=1.002072, probability=1.000000, bonus=1.000000, nodes=163)
                                @ 35  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=1.002072, probability=1.000000, bonus=1.000000, nodes=163)
                                @ 61  cd.Motion.<init>(CallSign, Vector3D, Vector3D):void (20 bytes)   relevance-based (relevance=1.002072, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=0.003972, bonus=1.000000, nodes=41 > 1.196345)
                                @ 64  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.002072, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 16  cd.CollisionDetector.lambda$handleNewFrame$0(RedBlackTree, Vector, Aircraft):void (68 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=75 <= 300.000000)
                                  @ 2  cd.RedBlackTree.findNode(Comparable):RedBlackTree$Node (51 bytes)   not inlining too large previous low-level graph (low-level-nodes: 345, relevance=1.490818, probability=1.000000, bonus=1.000000, nodes=42)
                                @ 8  cd.RedBlackTree.get(Comparable):Object (17 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=15 <= 300.000000)
                              @ 12  cd.CollisionDetector.lambda$handleNewFrame$1(RedBlackTree, Vector, RedBlackTree$Entry):void (32 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=38 <= 300.000000)
                            @ 8  cd.CollisionDetector.lambda$reduceCollisionSet$4(RedBlackTree, Motion):void (6 bytes)   inline method (bytecode parsing)
                            @ 4  cd.RedBlackTree.<init>():void (10 bytes)   inline method (bytecode parsing)
                                  @ 74  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=1.000897, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
                                @ 14  cd.CollisionDetector.voxelHash(Vector3D):Vector2D (78 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                                @ 18  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=1.000897, probability=1.000000, bonus=1.000000, nodes=92)
                              @ 2  cd.CollisionDetector.drawMotionOnVoxelMap(RedBlackTree, Motion):void (22 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=46 <= 300.000000)
                            @ 4  cd.RedBlackTree.<init>():void (10 bytes)   inline method (bytecode parsing)
                                @ 74  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=1.000901, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 14  cd.CollisionDetector.voxelHash(Vector3D):Vector2D (78 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 18  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=1.000901, probability=1.000000, bonus=1.000000, nodes=92)
                              @ 74  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=1.000901, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 12  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=1.001983, probability=1.000000, bonus=1.000000, nodes=163)
                              @ 35  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=1.001983, probability=1.000000, bonus=1.000000, nodes=163)
                              @ 61  cd.Motion.<init>(CallSign, Vector3D, Vector3D):void (20 bytes)   relevance-based (relevance=1.001983, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=0.003972, bonus=1.000000, nodes=41 > 1.196345)
                              @ 64  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.001983, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 8  cd.CollisionDetector.lambda$reduceCollisionSet$4(RedBlackTree, Motion):void (6 bytes)   inline method (bytecode parsing)
                              @ 20  cd.CollisionDetector$$Lambda/0x00007fe364008858.apply(Object):void (12 bytes)   not inlining too large previous low-level graph (low-level-nodes: 570, relevance=1.000000, probability=0.998172, bonus=1.000000, nodes=39)
                            @ 8  cd.CollisionDetector.lambda$reduceCollisionSet$4(RedBlackTree, Motion):void (6 bytes)   inline method (bytecode parsing)
                              @ 20  cd.CollisionDetector$$Lambda/0x00007fe364008858.apply(Object):void (12 bytes)   not inlining too large previous low-level graph (low-level-nodes: 570, relevance=1.000000, probability=543.975431, bonus=1.000000, nodes=39)
                            @ 4  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                            @ 27  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                              @ 12  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.000000, probability=2.000000, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 36  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=0.500000, probability=1.000000, bonus=1.000000, nodes=10 <= 150.000000)
                            @ 29  cd.Vector3D.squaredMagnitude():double (6 bytes)   inline method (bytecode parsing)
                            @ 70  cd.Vector3D.squaredMagnitude():double (6 bytes)   inline method (bytecode parsing)
                              @ 47  cd.Motion.findIntersection(Motion):Vector3D (348 bytes)   not inlining relevance-based (relevance=0.500000, probability=1.000000, bonus=1.000000, nodes=153 > 150.000000)
                              @ 73  cd.Collision.<init>(CallSign, CallSign, Vector3D):void (20 bytes)   relevance-based (relevance=0.173833, probability=0.347666, bonus=1.000000, nodes=14 <= 52.149871)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000693, probability=0.001381, bonus=1.000000, nodes=41 > 0.207964)
                              @ 76  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=0.173833, probability=0.347666, bonus=1.000000, nodes=35 <= 52.149871)
                              @ 2  cd.CollisionDetector.isInVoxel(Vector2D, Motion):boolean (420 bytes)   relevance-based (relevance=1.353325, probability=1.000000, bonus=1.000000, nodes=211 <= 300.000000)
                              @ 15  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=0.547344, probability=0.261079, bonus=1.000000, nodes=163)
                            @ 17  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                                  @ 2  cd.RedBlackTree.findNode(Comparable):RedBlackTree$Node (51 bytes)   not inlining too large previous low-level graph (low-level-nodes: 345, relevance=0.437410, probability=0.108829, bonus=1.000000, nodes=42)
                                @ 2  cd.RedBlackTree.get(Comparable):Object (17 bytes)   relevance-based (relevance=0.290208, probability=0.108829, bonus=1.000000, nodes=15 <= 87.062274)
                                @ 24  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=0.270358, probability=0.085560, bonus=1.000000, nodes=163)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.001371, probability=0.000432, bonus=1.000000, nodes=41 > 0.411405)
                                @ 30  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=0.343885, probability=0.108829, bonus=1.000000, nodes=35 <= 103.165537)
                              @ 28  cd.CollisionDetector.putIntoMap(RedBlackTree, Vector2D, Motion):void (34 bytes)   not inlining relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=80 > 68.447120)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 37  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                              @ 41  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 50  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                              @ 54  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 63  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                              @ 67  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 76  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                              @ 80  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 89  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 95  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                              @ 99  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 108  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 114  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                              @ 118  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 127  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 133  cd.Vector2D.minus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=16 <= 68.447120)
                              @ 137  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 146  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                                @ 22  cd.Vector2D.<init>(double, double):void (15 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=11 <= 68.447120)
                              @ 152  cd.Vector2D.plus(Vector2D):Vector2D (26 bytes)   relevance-based (relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=18 <= 68.447120)
                              @ 156  cd.CollisionDetector.recurse(RedBlackTree, RedBlackTree, Vector2D, Motion):void (160 bytes)   not inlining too large previous low-level graph (low-level-nodes: 633, relevance=0.228157, probability=0.108829, bonus=1.000000, nodes=92)
                            @ 8  cd.CollisionDetector.lambda$reduceCollisionSet$4(RedBlackTree, Motion):void (6 bytes)   inline method (bytecode parsing)
                              @ 20  cd.CollisionDetector$$Lambda/0x00007fe364008858.apply(Object):void (12 bytes)   not inlining too large previous low-level graph (low-level-nodes: 570, relevance=1.000000, probability=545.317308, bonus=1.000000, nodes=39)
                            @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                            @ 7  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.001404, probability=0.001034, bonus=1.000000, nodes=41 > 0.421165)
                                @ 22  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=0.352043, probability=0.260379, bonus=1.000000, nodes=35 <= 105.612943)
                              @ 8  cd.CollisionDetector.lambda$reduceCollisionSet$5(Vector, RedBlackTree$Entry):void (26 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=60 <= 300.000000)
                              @ 36  cd.RedBlackTree$Entry.<init>(Object, Object):void (15 bytes)   relevance-based (relevance=1.000000, probability=0.998832, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 39  cd.CollisionDetector$$Lambda/0x00007fe364008418.apply(Object):void (16 bytes)   not inlining too large previous low-level graph (low-level-nodes: 471, relevance=1.000000, probability=0.998832, bonus=1.000000, nodes=19)
                                @ 13  cd.RedBlackTree.treeMinimum(RedBlackTree$Node):RedBlackTree$Node (19 bytes)   relevance-based (relevance=1.000000, probability=0.513260, bonus=1.000000, nodes=16 <= 300.000000)
                              @ 45  cd.RedBlackTree$Node.successor():RedBlackTree$Node (46 bytes)   relevance-based (relevance=1.000000, probability=0.998832, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 36  cd.RedBlackTree$Entry.<init>(Object, Object):void (15 bytes)   relevance-based (relevance=1.000000, probability=853.376569, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 39  cd.CollisionDetector$$Lambda/0x00007fe364008418.apply(Object):void (16 bytes)   not inlining too large previous low-level graph (low-level-nodes: 471, relevance=1.000000, probability=853.376569, bonus=1.000000, nodes=19)
                                @ 13  cd.RedBlackTree.treeMinimum(RedBlackTree$Node):RedBlackTree$Node (19 bytes)   relevance-based (relevance=1.000000, probability=438.516163, bonus=1.000000, nodes=16 <= 300.000000)
                              @ 45  cd.RedBlackTree$Node.successor():RedBlackTree$Node (46 bytes)   relevance-based (relevance=1.000000, probability=853.376569, bonus=1.000000, nodes=49 <= 300.000000)
                              @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 22  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 12  cd.RedBlackTree.treeMinimum(RedBlackTree$Node):RedBlackTree$Node (19 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=16 <= 300.000000)
                              @ 36  cd.RedBlackTree$Entry.<init>(Object, Object):void (15 bytes)   relevance-based (relevance=1.000000, probability=846.169399, bonus=1.000000, nodes=11 <= 300.000000)
                              @ 39  cd.CollisionDetector$$Lambda/0x00007fe364008418.apply(Object):void (16 bytes)   not inlining too large previous low-level graph (low-level-nodes: 471, relevance=1.000000, probability=846.169399, bonus=1.000000, nodes=19)
                                @ 13  cd.RedBlackTree.treeMinimum(RedBlackTree$Node):RedBlackTree$Node (19 bytes)   relevance-based (relevance=1.000000, probability=434.812687, bonus=1.000000, nodes=16 <= 300.000000)
                              @ 45  cd.RedBlackTree$Node.successor():RedBlackTree$Node (46 bytes)   relevance-based (relevance=1.000000, probability=846.169399, bonus=1.000000, nodes=49 <= 300.000000)
                            @ 4  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                            @ 27  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                              @ 8  cd.CollisionDetector.lambda$handleNewFrame$3(Vector, Vector):void (92 bytes)   not inlining too large previous low-level graph (low-level-nodes: 458, relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=67)
                            @ 29  cd.Vector3D.squaredMagnitude():double (6 bytes)   inline method (bytecode parsing)
                            @ 70  cd.Vector3D.squaredMagnitude():double (6 bytes)   inline method (bytecode parsing)
                            @ 322  cd.Vector3D.magnitude():double (8 bytes)   inline method (bytecode parsing)
                              @ 1  cd.Vector3D.squaredMagnitude():double (6 bytes)   inline method (bytecode parsing)
                                  @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 8  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=23 <= 300.000000)
                              @ 11  cd.Motion.delta():Vector3D (12 bytes)   relevance-based (relevance=2.675855, probability=1.000000, bonus=1.000000, nodes=28 <= 300.000000)
                                  @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 8  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=23 <= 300.000000)
                              @ 17  cd.Motion.delta():Vector3D (12 bytes)   relevance-based (relevance=2.675855, probability=1.000000, bonus=1.000000, nodes=28 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 26  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=2.675855, probability=1.000000, bonus=1.000000, nodes=23 <= 300.000000)
                              @ 2  cd.Vector3D.dot(Vector3D):double (30 bytes)   relevance-based (relevance=2.675855, probability=1.000000, bonus=1.000000, nodes=16 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.995645, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 46  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=2.664201, probability=0.995645, bonus=1.000000, nodes=23 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.995645, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 53  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=2.664201, probability=0.995645, bonus=1.000000, nodes=23 <= 300.000000)
                              @ 56  cd.Vector3D.dot(Vector3D):double (30 bytes)   relevance-based (relevance=2.664201, probability=0.995645, bonus=1.000000, nodes=16 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.995645, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 67  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=2.664201, probability=0.995645, bonus=1.000000, nodes=23 <= 300.000000)
                              @ 2  cd.Vector3D.dot(Vector3D):double (30 bytes)   relevance-based (relevance=2.664201, probability=0.995645, bonus=1.000000, nodes=16 <= 300.000000)
                              @ 319  cd.Vector3D.minus(Vector3D):Vector3D (35 bytes)   not inlining relevance-based (relevance=0.011654, probability=0.004355, bonus=1.000000, nodes=18 > 3.496162)
                              @ 2  cd.Vector3D.dot(Vector3D):double (30 bytes)   not inlining relevance-based (relevance=0.011654, probability=0.004355, bonus=1.000000, nodes=16 > 3.496162)
                                @ 22  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 210  cd.Vector3D.times(double):Vector3D (26 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 213  cd.Vector3D.plus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=23 <= 300.000000)
                                @ 22  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 223  cd.Vector3D.times(double):Vector3D (26 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=20 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 226  cd.Vector3D.plus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=23 <= 300.000000)
                                @ 31  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 235  cd.Vector3D.plus(Vector3D):Vector3D (35 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=23 <= 300.000000)
                                @ 22  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.378902, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 241  cd.Vector3D.times(double):Vector3D (26 bytes)   relevance-based (relevance=1.013887, probability=0.378902, bonus=1.000000, nodes=20 <= 300.000000)
                              @ 5  cd.CallSign.compareTo(CallSign):int (32 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=12 <= 300.000000)
                              @ 2  cd.RedBlackTree.findNode(Comparable):RedBlackTree$Node (51 bytes)   not inlining too large previous low-level graph (low-level-nodes: 345, relevance=1.576131, probability=1.000000, bonus=1.000000, nodes=42)
                            @ 17  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                                @ 2  cd.RedBlackTree.findNode(Comparable):RedBlackTree$Node (51 bytes)   not inlining too large previous low-level graph (low-level-nodes: 345, relevance=1.576131, probability=1.000000, bonus=1.000000, nodes=42)
                              @ 2  cd.RedBlackTree.get(Comparable):Object (17 bytes)   relevance-based (relevance=1.269881, probability=1.000000, bonus=1.000000, nodes=15 <= 300.000000)
                              @ 24  cd.RedBlackTree.put(Comparable, Object):Object (365 bytes)   not inlining too large previous low-level graph (low-level-nodes: 3494, relevance=1.241164, probability=0.787475, bonus=1.000000, nodes=163)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=0.003972, bonus=1.000000, nodes=41 > 1.196345)
                              @ 30  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.576131, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 4  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                            @ 17  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                              @ 34  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.000000, probability=0.997995, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 62  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=0.997995, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 65  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.000000, probability=0.997995, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=0.003964, bonus=1.000000, nodes=41 > 1.196345)
                              @ 68  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000000, probability=0.997995, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 84  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.003988, probability=0.997995, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 112  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.003988, probability=0.997995, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 115  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.003988, probability=0.997995, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=0.003964, bonus=1.000000, nodes=41 > 1.196345)
                              @ 118  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.003988, probability=0.997995, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 34  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.000000, probability=495.721182, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 62  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=495.721182, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 65  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.000000, probability=495.721182, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=1.968993, bonus=1.000000, nodes=41 > 1.196345)
                              @ 68  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000000, probability=495.721182, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 84  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.003988, probability=495.721182, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 112  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.003988, probability=495.721182, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 115  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.003988, probability=495.721182, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=1.968993, bonus=1.000000, nodes=41 > 1.196345)
                              @ 118  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.003988, probability=495.721182, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 4  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                            @ 17  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                              @ 34  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.000000, probability=498.472973, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 62  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.000000, probability=498.472973, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 65  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.000000, probability=498.472973, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=1.979923, bonus=1.000000, nodes=41 > 1.196345)
                              @ 68  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000000, probability=498.472973, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 84  som.Vector.at(int):Object (18 bytes)   relevance-based (relevance=1.003988, probability=498.472973, bonus=1.000000, nodes=10 <= 300.000000)
                              @ 112  cd.Vector3D.<init>(double, double, double):void (21 bytes)   relevance-based (relevance=1.003988, probability=498.472973, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 115  cd.Aircraft.<init>(CallSign, Vector3D):void (15 bytes)   relevance-based (relevance=1.003988, probability=498.472973, bonus=1.000000, nodes=11 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.003988, probability=1.979923, bonus=1.000000, nodes=41 > 1.196345)
                              @ 118  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.003988, probability=498.472973, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 14  java.lang.Class.getComponentType():Class (14 bytes)   not inlining relevance-based (relevance=0.017265, probability=0.016972, bonus=1.000000, nodes=11 > 5.179599)
                              @ 32  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.017265, probability=1.000000, bonus=1.000000, nodes=7)
                              @ 1  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=9)
                            @ 3  java.lang.String.checkIndex(int, int):void (10 bytes)   inline method (bytecode parsing)
                              @ 12  java.lang.StringLatin1.charAt(byte[], int):char (15 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
