VM Arguments: 
sun.java.command=Harness Json 10 100
                              @ 44  java.lang.StringLatin1.equals(byte[], byte[]):boolean (36 bytes)   relevance-based (relevance=1.000000, probability=0.976894, bonus=1.000000, nodes=33 <= 300.000000)
                            @ 5  json.JsonPureStringParser.startCapture():void (9 bytes)   inline method (bytecode parsing)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999961, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000780, probability=0.999961, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.999961, bonus=1.000000, nodes=14 <= 300.000000)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000780, probability=0.999961, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000644, probability=0.999825, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.001507, probability=0.999467, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999825, bonus=1.000000, nodes=44 <= 300.000000)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000644, probability=0.999825, bonus=1.000000, nodes=58 <= 300.000000)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051495, probability=0.999961, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 1  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=162 <= 300.000000)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000780, probability=1.000000, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000780, probability=1.000000, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000644, probability=0.999864, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.001507, probability=0.999506, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999864, bonus=1.000000, nodes=44 <= 300.000000)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000644, probability=0.999864, bonus=1.000000, nodes=58 <= 300.000000)
                                @ 44  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 55  json.JsonPureStringParser.endCapture():String (96 bytes)   relevance-based (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=143 <= 300.000000)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999990, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=0.999990, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999951, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000780, probability=0.999951, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.999951, bonus=1.000000, nodes=14 <= 300.000000)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000780, probability=0.999951, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000644, probability=0.999815, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.001507, probability=0.999457, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999815, bonus=1.000000, nodes=44 <= 300.000000)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000644, probability=0.999815, bonus=1.000000, nodes=58 <= 300.000000)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051495, probability=0.999951, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 60  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=1.051525, probability=0.999990, bonus=1.000000, nodes=162 <= 300.000000)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.940934, probability=6.589646, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.940934, probability=6.589646, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.941631, probability=6.589388, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.941631, probability=6.589388, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.941631, probability=6.589388, bonus=1.000000, nodes=14 <= 282.489160)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.941631, probability=6.589388, bonus=1.000000, nodes=13 <= 282.489160)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.941503, probability=6.588495, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.942921, probability=6.586133, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.941503, probability=6.588495, bonus=1.000000, nodes=44 <= 282.450880)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.941503, probability=6.588495, bonus=1.000000, nodes=58 <= 282.450880)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.940897, probability=6.589388, bonus=1.000000, nodes=84 <= 282.269050)
                              @ 48  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.894819, probability=6.589646, bonus=1.000000, nodes=162 <= 268.445564)
                                @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                              @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000254, probability=1.000000, bonus=1.000000, nodes=8)
                                @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                              @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000254, probability=1.000000, bonus=1.000000, nodes=13 <= 300.000000)
                              @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000214, probability=0.999960, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                  @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000480, probability=0.999852, bonus=1.000000, nodes=7)
                                @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999960, bonus=1.000000, nodes=44 <= 300.000000)
                              @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000214, probability=0.999960, bonus=1.000000, nodes=58 <= 300.000000)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.999895, bonus=1.000000, nodes=7)
                              @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=44 <= 300.000000)
                            @ 19  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 47  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 56  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999956, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=0.999956, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.999956, bonus=1.000000, nodes=14 <= 300.000000)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=0.999956, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=0.999917, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.999812, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999917, bonus=1.000000, nodes=44 <= 300.000000)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=0.999917, bonus=1.000000, nodes=58 <= 300.000000)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051489, probability=0.999956, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 1  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=162 <= 300.000000)
                            @ 1  json.JsonValue.<init>():void (5 bytes)   inline method (bytecode parsing)
                            @ 9  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                              @ 8  json.JsonArray.<init>():void (16 bytes)   relevance-based (relevance=1.051525, probability=0.999990, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=0.999990, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 13  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.051525, probability=0.999990, bonus=1.000000, nodes=170 <= 300.000000)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.630670, probability=0.570366, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.630670, probability=0.570366, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.630799, probability=0.570341, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.630799, probability=0.570341, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.630799, probability=0.570341, bonus=1.000000, nodes=14 <= 189.239753)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.630799, probability=0.570341, bonus=1.000000, nodes=13 <= 189.239753)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.630775, probability=0.570319, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.631071, probability=0.570259, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.630775, probability=0.570319, bonus=1.000000, nodes=44 <= 189.232444)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.630775, probability=0.570319, bonus=1.000000, nodes=58 <= 189.232444)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.630642, probability=0.570341, bonus=1.000000, nodes=84 <= 189.192474)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.599760, probability=0.570366, bonus=1.000000, nodes=162 <= 179.928132)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   not inlining relevance-based (relevance=0.465604, probability=1.000000, bonus=1.000000, nodes=169 > 139.681255)
                              @ 28  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=0.465604, probability=1.000000, bonus=1.000000, nodes=10 <= 139.681255)
                              @ 33  json.JsonPureStringParser.readValue():JsonValue (526 bytes)   not inlining relevance-based (relevance=0.465604, probability=1.000000, bonus=1.000000, nodes=649 > 139.681255)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000233, probability=0.000501, bonus=1.000000, nodes=41 > 0.070040)
                                @ 19  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=0.465604, probability=1.000000, bonus=1.000000, nodes=35 <= 139.681255)
                              @ 36  json.JsonArray.add(JsonValue):JsonArray (24 bytes)   relevance-based (relevance=0.465604, probability=1.000000, bonus=1.000000, nodes=42 <= 139.681255)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   not inlining relevance-based (relevance=0.452002, probability=1.000000, bonus=1.000000, nodes=169 > 135.600542)
                              @ 41  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=0.452002, probability=1.000000, bonus=1.000000, nodes=10 <= 135.600542)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.271093, probability=0.570366, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.271093, probability=0.570366, bonus=1.000000, nodes=8)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining relevance-based (relevance=0.257807, probability=0.570366, bonus=1.000000, nodes=81 > 77.341967)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.270957, probability=0.245049, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.270957, probability=0.245049, bonus=1.000000, nodes=8)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining relevance-based (relevance=0.257677, probability=0.245049, bonus=1.000000, nodes=81 > 77.303205)
                            @ 1  json.JsonPureStringParser.startCapture():void (9 bytes)   inline method (bytecode parsing)
                            @ 7  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622075, probability=0.574016, bonus=1.000000, nodes=5)
                                @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622075, probability=0.574016, bonus=1.000000, nodes=8)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=14 <= 186.658019)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=13 <= 186.658019)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.622462, probability=0.573900, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=44 <= 186.650810)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=58 <= 186.650810)
                                @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.622038, probability=0.573982, bonus=1.000000, nodes=84 <= 186.611385)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.591587, probability=0.574016, bonus=1.000000, nodes=162 <= 177.476060)
                                @ 1  json.JsonPureStringParser.isDigit():boolean (126 bytes)   not inlining relevance-based (relevance=1.374610, probability=1.000000, bonus=1.000000, nodes=438 > 300.000000)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.727479, bonus=1.000000, nodes=5)
                                  @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=0.727479, bonus=1.000000, nodes=8)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.727436, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=0.727436, bonus=1.000000, nodes=8)
                                      @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.727436, bonus=1.000000, nodes=14 <= 300.000000)
                                    @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=0.727436, bonus=1.000000, nodes=13 <= 300.000000)
                                    @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=0.727408, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                        @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.727332, bonus=1.000000, nodes=7)
                                      @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.727408, bonus=1.000000, nodes=44 <= 300.000000)
                                    @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=0.727408, bonus=1.000000, nodes=58 <= 300.000000)
                                  @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051474, probability=0.727436, bonus=1.000000, nodes=84 <= 300.000000)
                                @ 10  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=1.000000, probability=0.727479, bonus=1.000000, nodes=162 <= 300.000000)
                              @ 17  json.JsonPureStringParser.readDigit():boolean (15 bytes)   relevance-based (relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=171 <= 300.000000)
                                @ 1  json.JsonPureStringParser.isDigit():boolean (126 bytes)   not inlining relevance-based (relevance=1.374610, probability=2.572621, bonus=1.000000, nodes=438 > 300.000000)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.871529, bonus=1.000000, nodes=5)
                                  @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=1.871529, bonus=1.000000, nodes=8)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.871418, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=1.871418, bonus=1.000000, nodes=8)
                                      @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=1.871418, bonus=1.000000, nodes=14 <= 300.000000)
                                    @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=1.871418, bonus=1.000000, nodes=13 <= 300.000000)
                                    @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=1.871346, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                        @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=1.871149, bonus=1.000000, nodes=7)
                                      @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=1.871346, bonus=1.000000, nodes=44 <= 300.000000)
                                    @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=1.871346, bonus=1.000000, nodes=58 <= 300.000000)
                                  @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051474, probability=1.871418, bonus=1.000000, nodes=84 <= 300.000000)
                                @ 10  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=1.000000, probability=1.871529, bonus=1.000000, nodes=162 <= 300.000000)
                              @ 40  json.JsonPureStringParser.readDigit():boolean (15 bytes)   relevance-based (relevance=1.608873, probability=2.572621, bonus=1.000000, nodes=171 <= 300.000000)
                            @ 3  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622075, probability=0.574016, bonus=1.000000, nodes=5)
                                  @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622075, probability=0.574016, bonus=1.000000, nodes=8)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=8)
                                      @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=14 <= 186.658019)
                                    @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.622193, probability=0.573982, bonus=1.000000, nodes=13 <= 186.658019)
                                    @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                        @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.622462, probability=0.573900, bonus=1.000000, nodes=7)
                                      @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=44 <= 186.650810)
                                    @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.622169, probability=0.573960, bonus=1.000000, nodes=58 <= 186.650810)
                                  @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.622038, probability=0.573982, bonus=1.000000, nodes=84 <= 186.611385)
                                @ 14  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.591587, probability=0.574016, bonus=1.000000, nodes=162 <= 177.476060)
                              @ 50  json.JsonPureStringParser.readFraction():boolean (37 bytes)   relevance-based (relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=205 <= 300.000000)
                            @ 3  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 12  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622075, probability=0.574013, bonus=1.000000, nodes=5)
                                  @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622075, probability=0.574013, bonus=1.000000, nodes=8)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622193, probability=0.573979, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622193, probability=0.573979, bonus=1.000000, nodes=8)
                                      @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.622193, probability=0.573979, bonus=1.000000, nodes=14 <= 186.658019)
                                    @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.622193, probability=0.573979, bonus=1.000000, nodes=13 <= 186.658019)
                                    @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.622169, probability=0.573957, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                        @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.622462, probability=0.573896, bonus=1.000000, nodes=7)
                                      @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.622169, probability=0.573957, bonus=1.000000, nodes=44 <= 186.650810)
                                    @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.622169, probability=0.573957, bonus=1.000000, nodes=58 <= 186.650810)
                                  @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.622038, probability=0.573979, bonus=1.000000, nodes=84 <= 186.611385)
                                @ 14  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.591587, probability=0.574013, bonus=1.000000, nodes=162 <= 177.476060)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622071, probability=0.574010, bonus=1.000000, nodes=5)
                                  @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622071, probability=0.574010, bonus=1.000000, nodes=8)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=0.622190, probability=0.573976, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=0.622190, probability=0.573976, bonus=1.000000, nodes=8)
                                      @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=0.622190, probability=0.573976, bonus=1.000000, nodes=14 <= 186.656948)
                                    @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=0.622190, probability=0.573976, bonus=1.000000, nodes=13 <= 186.656948)
                                    @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=0.622166, probability=0.573953, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                        @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=0.622458, probability=0.573893, bonus=1.000000, nodes=7)
                                      @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=0.622166, probability=0.573953, bonus=1.000000, nodes=44 <= 186.649739)
                                    @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=0.622166, probability=0.573953, bonus=1.000000, nodes=58 <= 186.649739)
                                  @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=0.622034, probability=0.573976, bonus=1.000000, nodes=84 <= 186.610314)
                                @ 14  json.JsonPureStringParser.read():void (81 bytes)   relevance-based (relevance=0.591583, probability=0.574010, bonus=1.000000, nodes=162 <= 177.475042)
                              @ 55  json.JsonPureStringParser.readExponent():boolean (62 bytes)   not inlining relevance-based (relevance=1.030604, probability=0.999994, bonus=1.000000, nodes=398 > 300.000000)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999994, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=0.999994, bonus=1.000000, nodes=8)
                                    @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.999994, bonus=1.000000, nodes=14 <= 300.000000)
                                  @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=0.999994, bonus=1.000000, nodes=13 <= 300.000000)
                                  @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=0.999956, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                      @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.999850, bonus=1.000000, nodes=7)
                                    @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999956, bonus=1.000000, nodes=44 <= 300.000000)
                                  @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=0.999956, bonus=1.000000, nodes=58 <= 300.000000)
                                @ 44  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051536, probability=0.999994, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 64  json.JsonPureStringParser.endCapture():String (96 bytes)   relevance-based (relevance=1.030604, probability=0.999994, bonus=1.000000, nodes=143 <= 300.000000)
                            @ 1  json.JsonValue.<init>():void (5 bytes)   inline method (bytecode parsing)
                              @ 67  json.JsonNumber.<init>(String):void (24 bytes)   trivial (relevance=1.030594, probability=0.999984, bonus=1.000000, nodes=8)
                                @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                              @ 45  java.lang.String.length():int (11 bytes)   trivial (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=8)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=0.999927, bonus=1.000000, nodes=5)
                                @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=0.999927, bonus=1.000000, nodes=8)
                                  @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=0.999927, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=0.999927, bonus=1.000000, nodes=13 <= 300.000000)
                                @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=0.999889, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                    @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.999783, bonus=1.000000, nodes=7)
                                  @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999889, bonus=1.000000, nodes=44 <= 300.000000)
                                @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=0.999889, bonus=1.000000, nodes=58 <= 300.000000)
                              @ 66  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051459, probability=0.999927, bonus=1.000000, nodes=84 <= 300.000000)
                              @ 17  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000000, probability=0.937793, bonus=1.000000, nodes=9)
                              @ 27  java.lang.StringLatin1.hashCode(byte[]):int (52 bytes)   relevance-based (relevance=1.000000, probability=0.937793, bonus=1.000000, nodes=22 <= 300.000000)
                                @ 17  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000000, probability=0.936831, bonus=1.000000, nodes=9)
                                @ 27  java.lang.StringLatin1.hashCode(byte[]):int (52 bytes)   relevance-based (relevance=1.000000, probability=0.936831, bonus=1.000000, nodes=22 <= 300.000000)
                              @ 8  java.lang.String.hashCode():int (60 bytes)   relevance-based (relevance=2.587556, probability=1.000000, bonus=1.000000, nodes=47 <= 300.000000)
                            @ 1  json.JsonPureStringParser.startCapture():void (9 bytes)   inline method (bytecode parsing)
                            @ 7  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 515  json.JsonPureStringParser.readNumber():JsonValue (71 bytes)   not inlining too large previous low-level graph (low-level-nodes: 2164, relevance=0.226612, probability=0.209842, bonus=1.000000, nodes=127)
                            @ 19  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 43  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 77  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 86  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 510  json.JsonPureStringParser.readObject():JsonObject (101 bytes)   not inlining relevance-based (relevance=0.049926, probability=0.046231, bonus=1.000000, nodes=220 > 14.977798)
                            @ 19  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 47  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 56  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 505  json.JsonPureStringParser.readArray():JsonArray (71 bytes)   not inlining too large previous low-level graph (low-level-nodes: 1691, relevance=0.176046, probability=0.163017, bonus=1.000000, nodes=163)
                            @ 8  json.JsonString.<init>(String):void (10 bytes)   inline method (bytecode parsing)
                              @ 1  json.JsonValue.<init>():void (5 bytes)   inline method (bytecode parsing)
                            @ 5  json.JsonPureStringParser.startCapture():void (9 bytes)   inline method (bytecode parsing)
                                @ 5  json.JsonPureStringParser.readStringInternal():String (65 bytes)   not inlining too large previous low-level graph (low-level-nodes: 1782, relevance=0.430127, probability=0.398295, bonus=1.000000, nodes=98)
                              @ 500  json.JsonPureStringParser.readString():JsonValue (12 bytes)   relevance-based (relevance=0.430127, probability=0.398295, bonus=1.000000, nodes=12 <= 129.038075)
                            @ 7  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 13  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 19  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 25  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 495  json.JsonPureStringParser.readFalse():JsonValue (32 bytes)   not inlining relevance-based (relevance=0.000953, probability=0.000882, bonus=1.000000, nodes=207 > 0.285788)
                            @ 7  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 13  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 19  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 490  json.JsonPureStringParser.readTrue():JsonValue (26 bytes)   not inlining relevance-based (relevance=0.008200, probability=0.007593, bonus=1.000000, nodes=158 > 2.460093)
                            @ 7  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 13  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 19  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 485  json.JsonPureStringParser.readNull():JsonValue (26 bytes)   not inlining relevance-based (relevance=0.188057, probability=0.174139, bonus=1.000000, nodes=156 > 56.417047)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                              @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000398, probability=0.000398, bonus=1.000000, nodes=41 > 0.119377)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000250, probability=1.000000, bonus=1.000000, nodes=8)
                                  @ 6  jdk.internal.util.Preconditions.checkFromToIndex(int, int, int, BiFunction):int (24 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=14 <= 300.000000)
                                @ 8  java.lang.String.checkBoundsBeginEnd(int, int, int):void (11 bytes)   relevance-based (relevance=1.000250, probability=1.000000, bonus=1.000000, nodes=13 <= 300.000000)
                                @ 28  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000211, probability=0.999961, bonus=1.000000, nodes=9)
                            @ 20  java.lang.String.<init>(byte[], byte):void (15 bytes)   inline method (bytecode parsing)
                            @ 13  java.util.Arrays.copyOfRangeByte(byte[], int, int):byte[] (33 bytes)   inline method (bytecode parsing)
                              @ 2  java.util.Arrays.checkLength(int, int):void (38 bytes)   inline method (bytecode parsing)
                                    @ 24  java.lang.Math.min(int, int):int (11 bytes)   trivial (relevance=1.000470, probability=0.999856, bonus=1.000000, nodes=7)
                                  @ 16  java.util.Arrays.copyOfRange(byte[], int, int):byte[] (25 bytes)   relevance-based (relevance=1.000000, probability=0.999961, bonus=1.000000, nodes=44 <= 300.000000)
                                @ 41  java.lang.StringLatin1.newString(byte[], int, int):String (24 bytes)   relevance-based (relevance=1.000211, probability=0.999961, bonus=1.000000, nodes=58 <= 300.000000)
                              @ 44  java.lang.String.substring(int, int):String (58 bytes)   relevance-based (relevance=1.051536, probability=1.000000, bonus=1.000000, nodes=84 <= 300.000000)
                            @ 3  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 12  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.571795, probability=0.554812, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.571795, probability=0.554812, bonus=1.000000, nodes=77)
                            @ 19  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 43  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 77  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 86  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 1  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=77)
                            @ 1  json.JsonValue.<init>():void (5 bytes)   inline method (bytecode parsing)
                            @ 9  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                            @ 20  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                                @ 31  json.JsonObject$HashIndexTable.<init>():void (13 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=9)
                              @ 8  json.JsonObject.<init>():void (38 bytes)   relevance-based (relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=31 <= 300.000000)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 13  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=170 <= 300.000000)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.582506, probability=0.553958, bonus=1.000000, nodes=77)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 28  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.030610, probability=2.241939, bonus=1.000000, nodes=170 <= 300.000000)
                            @ 5  json.JsonPureStringParser.startCapture():void (9 bytes)   inline method (bytecode parsing)
                                @ 20  json.JsonPureStringParser.readStringInternal():String (65 bytes)   not inlining too large previous low-level graph (low-level-nodes: 1782, relevance=1.030610, probability=2.241939, bonus=1.000000, nodes=98)
                              @ 32  json.JsonPureStringParser.readName():String (24 bytes)   relevance-based (relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=44 <= 300.000000)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 37  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=170 <= 300.000000)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=77)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 57  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=170 <= 300.000000)
                              @ 63  json.JsonPureStringParser.readValue():JsonValue (526 bytes)   not inlining too large previous low-level graph (low-level-nodes: 596, relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=649)
                            @ 37  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                            @ 2  json.JsonObject$HashIndexTable.stringHash(String):int (8 bytes)   inline method (bytecode parsing)
                                      @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=5)
                                    @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=8)
                                  @ 2  json.JsonObject$HashIndexTable.hashSlotFor(String):int (14 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=19 <= 300.000000)
                                @ 40  json.JsonObject$HashIndexTable.add(String, int):void (37 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=29 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000393, probability=0.000881, bonus=1.000000, nodes=41 > 0.117962)
                                @ 48  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                  @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000393, probability=0.000881, bonus=1.000000, nodes=41 > 0.117962)
                                @ 56  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000393, probability=2.241939, bonus=1.000000, nodes=35 <= 300.000000)
                              @ 66  json.JsonObject.add(String, JsonValue):JsonObject (61 bytes)   relevance-based (relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=112 <= 300.000000)
                                @ 1  json.JsonPureStringParser.isWhiteSpace():boolean (54 bytes)   relevance-based (relevance=1.000000, probability=2.241939, bonus=1.000000, nodes=169 <= 300.000000)
                              @ 71  json.JsonPureStringParser.skipWhiteSpace():void (15 bytes)   relevance-based (relevance=1.051536, probability=2.241939, bonus=1.000000, nodes=170 <= 300.000000)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.582506, probability=1.241939, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.582506, probability=0.553958, bonus=1.000000, nodes=77)
                            @ 37  som.Vector.size():int (10 bytes)   inline method (bytecode parsing)
                            @ 2  json.JsonObject$HashIndexTable.stringHash(String):int (8 bytes)   inline method (bytecode parsing)
                                    @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                  @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=8)
                                @ 2  json.JsonObject$HashIndexTable.hashSlotFor(String):int (14 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=19 <= 300.000000)
                              @ 40  json.JsonObject$HashIndexTable.add(String, int):void (37 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=29 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000393, probability=0.000393, bonus=1.000000, nodes=41 > 0.117962)
                              @ 48  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 24  java.util.Arrays.copyOf(Object[], int):Object[] (10 bytes)   inline method (bytecode parsing)
                                @ 6  java.util.Arrays.copyOf(Object[], int, Class):Object[] (40 bytes)   not inlining relevance-based (relevance=0.000393, probability=0.000393, bonus=1.000000, nodes=41 > 0.117962)
                              @ 56  som.Vector.append(Object):void (51 bytes)   relevance-based (relevance=1.000393, probability=1.000000, bonus=1.000000, nodes=35 <= 300.000000)
                            @ 2  json.JsonObject$HashIndexTable.stringHash(String):int (8 bytes)   inline method (bytecode parsing)
                                  @ 6  java.lang.String.coder():byte (15 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=5)
                                @ 1  java.lang.String.length():int (11 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=8)
                              @ 2  json.JsonObject$HashIndexTable.hashSlotFor(String):int (14 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=19 <= 300.000000)
                            @ 3  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.594055, probability=0.576411, bonus=1.000000, nodes=77)
                            @ 1  json.JsonValue.<init>():void (5 bytes)   inline method (bytecode parsing)
                            @ 9  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                            @ 20  som.Vector.<init>():void (7 bytes)   inline method (bytecode parsing)
                              @ 3  som.Vector.<init>(int):void (13 bytes)   inline method (bytecode parsing)
                              @ 31  json.JsonObject$HashIndexTable.<init>():void (13 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=9)
                                @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.606560, probability=0.576833, bonus=1.000000, nodes=77)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=63 <= 300.000000)
                            @ 7  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 13  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 19  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 1  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.594624, probability=0.576963, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.594624, probability=0.576963, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.594624, probability=0.576963, bonus=1.000000, nodes=77)
                            @ 7  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 13  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                            @ 19  json.JsonPureStringParser.readRequiredChar(String):void (20 bytes)   inline method (bytecode parsing)
                              @ 2  json.JsonPureStringParser.readChar(String):boolean (19 bytes)   inline method (bytecode parsing)
                              @ 1  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=1.030610, probability=1.000000, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.595392, probability=0.577708, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.595392, probability=0.577708, bonus=1.000000, nodes=77)
                              @ 14  json.JsonPureStringParser.read():void (81 bytes)   not inlining too large previous low-level graph (low-level-nodes: 402, relevance=0.595392, probability=0.577708, bonus=1.000000, nodes=77)
                              @ 1  java.lang.String.isLatin1():boolean (19 bytes)   trivial (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=9)
                            @ 3  java.lang.String.checkIndex(int, int):void (10 bytes)   inline method (bytecode parsing)
                              @ 12  java.lang.StringLatin1.charAt(byte[], int):char (15 bytes)   relevance-based (relevance=1.000000, probability=1.000000, bonus=1.000000, nodes=11 <= 300.000000)
